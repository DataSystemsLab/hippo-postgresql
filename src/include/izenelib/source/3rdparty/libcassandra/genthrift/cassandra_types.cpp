/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "cassandra_types.h"

#include <algorithm>

namespace org { namespace apache { namespace cassandra {

int _kConsistencyLevelValues[] = {
  ConsistencyLevel::ONE,
  ConsistencyLevel::QUORUM,
  ConsistencyLevel::LOCAL_QUORUM,
  ConsistencyLevel::EACH_QUORUM,
  ConsistencyLevel::ALL,
  ConsistencyLevel::ANY,
  ConsistencyLevel::TWO,
  ConsistencyLevel::THREE
};
const char* _kConsistencyLevelNames[] = {
  "ONE",
  "QUORUM",
  "LOCAL_QUORUM",
  "EACH_QUORUM",
  "ALL",
  "ANY",
  "TWO",
  "THREE"
};
const std::map<int, const char*> _ConsistencyLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kConsistencyLevelValues, _kConsistencyLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kIndexOperatorValues[] = {
  IndexOperator::EQ,
  IndexOperator::GTE,
  IndexOperator::GT,
  IndexOperator::LTE,
  IndexOperator::LT
};
const char* _kIndexOperatorNames[] = {
  "EQ",
  "GTE",
  "GT",
  "LTE",
  "LT"
};
const std::map<int, const char*> _IndexOperator_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kIndexOperatorValues, _kIndexOperatorNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kIndexTypeValues[] = {
  IndexType::KEYS,
  IndexType::CUSTOM,
  IndexType::COMPOSITES
};
const char* _kIndexTypeNames[] = {
  "KEYS",
  "CUSTOM",
  "COMPOSITES"
};
const std::map<int, const char*> _IndexType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kIndexTypeValues, _kIndexTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCompressionValues[] = {
  Compression::GZIP,
  Compression::NONE
};
const char* _kCompressionNames[] = {
  "GZIP",
  "NONE"
};
const std::map<int, const char*> _Compression_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCompressionValues, _kCompressionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCqlResultTypeValues[] = {
  CqlResultType::ROWS,
  CqlResultType::VOID,
  CqlResultType::INT
};
const char* _kCqlResultTypeNames[] = {
  "ROWS",
  "VOID",
  "INT"
};
const std::map<int, const char*> _CqlResultType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCqlResultTypeValues, _kCqlResultTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* Column::ascii_fingerprint = "3EE0E1C5C844001B62F08125068292CC";
const uint8_t Column::binary_fingerprint[16] = {0x3E,0xE0,0xE1,0xC5,0xC8,0x44,0x00,0x1B,0x62,0xF0,0x81,0x25,0x06,0x82,0x92,0xCC};

uint32_t Column::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ttl);
          this->__isset.ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Column::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Column");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ttl) {
    xfer += oprot->writeFieldBegin("ttl", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->ttl);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Column &a, Column &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
  swap(a.timestamp, b.timestamp);
  swap(a.ttl, b.ttl);
  swap(a.__isset, b.__isset);
}

const char* SuperColumn::ascii_fingerprint = "470EFC558004E98D92D604898305C04E";
const uint8_t SuperColumn::binary_fingerprint[16] = {0x47,0x0E,0xFC,0x55,0x80,0x04,0xE9,0x8D,0x92,0xD6,0x04,0x89,0x83,0x05,0xC0,0x4E};

uint32_t SuperColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->columns.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->columns[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SuperColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SuperColumn");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<Column> ::const_iterator _iter5;
    for (_iter5 = this->columns.begin(); _iter5 != this->columns.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SuperColumn &a, SuperColumn &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.columns, b.columns);
}

const char* CounterColumn::ascii_fingerprint = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
const uint8_t CounterColumn::binary_fingerprint[16] = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};

uint32_t CounterColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CounterColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CounterColumn");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CounterColumn &a, CounterColumn &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
}

const char* CounterSuperColumn::ascii_fingerprint = "CD4C8C4BF7753E46DE417CDE369343A4";
const uint8_t CounterSuperColumn::binary_fingerprint[16] = {0xCD,0x4C,0x8C,0x4B,0xF7,0x75,0x3E,0x46,0xDE,0x41,0x7C,0xDE,0x36,0x93,0x43,0xA4};

uint32_t CounterSuperColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->columns.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->columns[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CounterSuperColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CounterSuperColumn");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<CounterColumn> ::const_iterator _iter11;
    for (_iter11 = this->columns.begin(); _iter11 != this->columns.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CounterSuperColumn &a, CounterSuperColumn &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.columns, b.columns);
}

const char* ColumnOrSuperColumn::ascii_fingerprint = "2B34AC9E80F1DAA3A2A63B1AB1841E61";
const uint8_t ColumnOrSuperColumn::binary_fingerprint[16] = {0x2B,0x34,0xAC,0x9E,0x80,0xF1,0xDA,0xA3,0xA2,0xA6,0x3B,0x1A,0xB1,0x84,0x1E,0x61};

uint32_t ColumnOrSuperColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column.read(iprot);
          this->__isset.column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->super_column.read(iprot);
          this->__isset.super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->counter_column.read(iprot);
          this->__isset.counter_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->counter_super_column.read(iprot);
          this->__isset.counter_super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnOrSuperColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnOrSuperColumn");

  if (this->__isset.column) {
    xfer += oprot->writeFieldBegin("column", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->column.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.super_column) {
    xfer += oprot->writeFieldBegin("super_column", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->super_column.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.counter_column) {
    xfer += oprot->writeFieldBegin("counter_column", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->counter_column.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.counter_super_column) {
    xfer += oprot->writeFieldBegin("counter_super_column", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->counter_super_column.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnOrSuperColumn &a, ColumnOrSuperColumn &b) {
  using ::std::swap;
  swap(a.column, b.column);
  swap(a.super_column, b.super_column);
  swap(a.counter_column, b.counter_column);
  swap(a.counter_super_column, b.counter_super_column);
  swap(a.__isset, b.__isset);
}

const char* NotFoundException::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t NotFoundException::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t NotFoundException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NotFoundException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NotFoundException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NotFoundException &a, NotFoundException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* InvalidRequestException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t InvalidRequestException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t InvalidRequestException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t InvalidRequestException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("InvalidRequestException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidRequestException &a, InvalidRequestException &b) {
  using ::std::swap;
  swap(a.why, b.why);
}

const char* UnavailableException::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t UnavailableException::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t UnavailableException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnavailableException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UnavailableException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnavailableException &a, UnavailableException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* TimedOutException::ascii_fingerprint = "66B98FA31E5D1C70A3C9D6A8C5E65F30";
const uint8_t TimedOutException::binary_fingerprint[16] = {0x66,0xB9,0x8F,0xA3,0x1E,0x5D,0x1C,0x70,0xA3,0xC9,0xD6,0xA8,0xC5,0xE6,0x5F,0x30};

uint32_t TimedOutException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->acknowledged_by);
          this->__isset.acknowledged_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->acknowledged_by_batchlog);
          this->__isset.acknowledged_by_batchlog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TimedOutException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TimedOutException");

  if (this->__isset.acknowledged_by) {
    xfer += oprot->writeFieldBegin("acknowledged_by", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->acknowledged_by);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.acknowledged_by_batchlog) {
    xfer += oprot->writeFieldBegin("acknowledged_by_batchlog", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->acknowledged_by_batchlog);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TimedOutException &a, TimedOutException &b) {
  using ::std::swap;
  swap(a.acknowledged_by, b.acknowledged_by);
  swap(a.acknowledged_by_batchlog, b.acknowledged_by_batchlog);
  swap(a.__isset, b.__isset);
}

const char* AuthenticationException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t AuthenticationException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t AuthenticationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AuthenticationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuthenticationException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuthenticationException &a, AuthenticationException &b) {
  using ::std::swap;
  swap(a.why, b.why);
}

const char* AuthorizationException::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t AuthorizationException::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t AuthorizationException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_why = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          isset_why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_why)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AuthorizationException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuthorizationException");

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuthorizationException &a, AuthorizationException &b) {
  using ::std::swap;
  swap(a.why, b.why);
}

const char* SchemaDisagreementException::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t SchemaDisagreementException::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t SchemaDisagreementException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaDisagreementException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SchemaDisagreementException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaDisagreementException &a, SchemaDisagreementException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* ColumnParent::ascii_fingerprint = "0A13AE61181713A4100DFFB3EC293822";
const uint8_t ColumnParent::binary_fingerprint[16] = {0x0A,0x13,0xAE,0x61,0x18,0x17,0x13,0xA4,0x10,0x0D,0xFF,0xB3,0xEC,0x29,0x38,0x22};

uint32_t ColumnParent::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_family = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          isset_column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->super_column);
          this->__isset.super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnParent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnParent");

  xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.super_column) {
    xfer += oprot->writeFieldBegin("super_column", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->super_column);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnParent &a, ColumnParent &b) {
  using ::std::swap;
  swap(a.column_family, b.column_family);
  swap(a.super_column, b.super_column);
  swap(a.__isset, b.__isset);
}

const char* ColumnPath::ascii_fingerprint = "606212895BCF63C757913CF35AEB3462";
const uint8_t ColumnPath::binary_fingerprint[16] = {0x60,0x62,0x12,0x89,0x5B,0xCF,0x63,0xC7,0x57,0x91,0x3C,0xF3,0x5A,0xEB,0x34,0x62};

uint32_t ColumnPath::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_family = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          isset_column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->super_column);
          this->__isset.super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->column);
          this->__isset.column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnPath::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnPath");

  xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.super_column) {
    xfer += oprot->writeFieldBegin("super_column", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->super_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column) {
    xfer += oprot->writeFieldBegin("column", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->column);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnPath &a, ColumnPath &b) {
  using ::std::swap;
  swap(a.column_family, b.column_family);
  swap(a.super_column, b.super_column);
  swap(a.column, b.column);
  swap(a.__isset, b.__isset);
}

const char* SliceRange::ascii_fingerprint = "184D24C9A0B8D4415E234DB649CAE740";
const uint8_t SliceRange::binary_fingerprint[16] = {0x18,0x4D,0x24,0xC9,0xA0,0xB8,0xD4,0x41,0x5E,0x23,0x4D,0xB6,0x49,0xCA,0xE7,0x40};

uint32_t SliceRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_start = false;
  bool isset_finish = false;
  bool isset_reversed = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start);
          isset_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->finish);
          isset_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reversed);
          isset_reversed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_start)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_finish)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_reversed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SliceRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SliceRange");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->finish);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reversed", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->reversed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SliceRange &a, SliceRange &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.reversed, b.reversed);
  swap(a.count, b.count);
}

const char* SlicePredicate::ascii_fingerprint = "F59D1D81C17DFFAF09988BF1C9CE5E27";
const uint8_t SlicePredicate::binary_fingerprint[16] = {0xF5,0x9D,0x1D,0x81,0xC1,0x7D,0xFF,0xAF,0x09,0x98,0x8B,0xF1,0xC9,0xCE,0x5E,0x27};

uint32_t SlicePredicate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_names.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->column_names.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readBinary(this->column_names[_i16]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->slice_range.read(iprot);
          this->__isset.slice_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SlicePredicate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SlicePredicate");

  if (this->__isset.column_names) {
    xfer += oprot->writeFieldBegin("column_names", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_names.size()));
      std::vector<std::string> ::const_iterator _iter17;
      for (_iter17 = this->column_names.begin(); _iter17 != this->column_names.end(); ++_iter17)
      {
        xfer += oprot->writeBinary((*_iter17));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.slice_range) {
    xfer += oprot->writeFieldBegin("slice_range", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->slice_range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SlicePredicate &a, SlicePredicate &b) {
  using ::std::swap;
  swap(a.column_names, b.column_names);
  swap(a.slice_range, b.slice_range);
  swap(a.__isset, b.__isset);
}

const char* IndexExpression::ascii_fingerprint = "D9F4CFE2F293A8B1052FD3031DD2C847";
const uint8_t IndexExpression::binary_fingerprint[16] = {0xD9,0xF4,0xCF,0xE2,0xF2,0x93,0xA8,0xB1,0x05,0x2F,0xD3,0x03,0x1D,0xD2,0xC8,0x47};

uint32_t IndexExpression::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_column_name = false;
  bool isset_op = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->column_name);
          isset_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->op = (IndexOperator::type)ecast18;
          isset_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t IndexExpression::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("IndexExpression");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexExpression &a, IndexExpression &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.op, b.op);
  swap(a.value, b.value);
}

const char* IndexClause::ascii_fingerprint = "9B551B9AB86120B0EEA9005C77FD3C1F";
const uint8_t IndexClause::binary_fingerprint[16] = {0x9B,0x55,0x1B,0x9A,0xB8,0x61,0x20,0xB0,0xEE,0xA9,0x00,0x5C,0x77,0xFD,0x3C,0x1F};

uint32_t IndexClause::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_expressions = false;
  bool isset_start_key = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->expressions.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->expressions.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->expressions[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_expressions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start_key);
          isset_start_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_expressions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t IndexClause::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("IndexClause");

  xfer += oprot->writeFieldBegin("expressions", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->expressions.size()));
    std::vector<IndexExpression> ::const_iterator _iter24;
    for (_iter24 = this->expressions.begin(); _iter24 != this->expressions.end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->start_key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexClause &a, IndexClause &b) {
  using ::std::swap;
  swap(a.expressions, b.expressions);
  swap(a.start_key, b.start_key);
  swap(a.count, b.count);
}

const char* KeyRange::ascii_fingerprint = "A6EC82FA0980B91C7C8EB013C61CA1B0";
const uint8_t KeyRange::binary_fingerprint[16] = {0xA6,0xEC,0x82,0xFA,0x09,0x80,0xB9,0x1C,0x7C,0x8E,0xB0,0x13,0xC6,0x1C,0xA1,0xB0};

uint32_t KeyRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->start_key);
          this->__isset.start_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->end_key);
          this->__isset.end_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_token);
          this->__isset.start_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_token);
          this->__isset.end_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_filter.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->row_filter.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->row_filter[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.row_filter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeyRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KeyRange");

  if (this->__isset.start_key) {
    xfer += oprot->writeFieldBegin("start_key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->start_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_key) {
    xfer += oprot->writeFieldBegin("end_key", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->end_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.start_token) {
    xfer += oprot->writeFieldBegin("start_token", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->start_token);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.end_token) {
    xfer += oprot->writeFieldBegin("end_token", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->end_token);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.row_filter) {
    xfer += oprot->writeFieldBegin("row_filter", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->row_filter.size()));
      std::vector<IndexExpression> ::const_iterator _iter30;
      for (_iter30 = this->row_filter.begin(); _iter30 != this->row_filter.end(); ++_iter30)
      {
        xfer += (*_iter30).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyRange &a, KeyRange &b) {
  using ::std::swap;
  swap(a.start_key, b.start_key);
  swap(a.end_key, b.end_key);
  swap(a.start_token, b.start_token);
  swap(a.end_token, b.end_token);
  swap(a.row_filter, b.row_filter);
  swap(a.count, b.count);
  swap(a.__isset, b.__isset);
}

const char* KeySlice::ascii_fingerprint = "D1568675B0C135C909E3169B72A4DA3D";
const uint8_t KeySlice::binary_fingerprint[16] = {0xD1,0x56,0x86,0x75,0xB0,0xC1,0x35,0xC9,0x09,0xE3,0x16,0x9B,0x72,0xA4,0xDA,0x3D};

uint32_t KeySlice::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->columns.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->columns[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeySlice::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KeySlice");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<ColumnOrSuperColumn> ::const_iterator _iter36;
    for (_iter36 = this->columns.begin(); _iter36 != this->columns.end(); ++_iter36)
    {
      xfer += (*_iter36).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeySlice &a, KeySlice &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.columns, b.columns);
}

const char* KeyCount::ascii_fingerprint = "EEBC915CE44901401D881E6091423036";
const uint8_t KeyCount::binary_fingerprint[16] = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

uint32_t KeyCount::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeyCount::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KeyCount");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KeyCount &a, KeyCount &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.count, b.count);
}

const char* Deletion::ascii_fingerprint = "40F33ECF1C932CA77C2414C4E6C60CBE";
const uint8_t Deletion::binary_fingerprint[16] = {0x40,0xF3,0x3E,0xCF,0x1C,0x93,0x2C,0xA7,0x7C,0x24,0x14,0xC4,0xE6,0xC6,0x0C,0xBE};

uint32_t Deletion::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->super_column);
          this->__isset.super_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->predicate.read(iprot);
          this->__isset.predicate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Deletion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Deletion");

  if (this->__isset.timestamp) {
    xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->timestamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.super_column) {
    xfer += oprot->writeFieldBegin("super_column", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->super_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.predicate) {
    xfer += oprot->writeFieldBegin("predicate", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->predicate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Deletion &a, Deletion &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.super_column, b.super_column);
  swap(a.predicate, b.predicate);
  swap(a.__isset, b.__isset);
}

const char* Mutation::ascii_fingerprint = "E8B65DF3979C6868F80DF81F8E769E63";
const uint8_t Mutation::binary_fingerprint[16] = {0xE8,0xB6,0x5D,0xF3,0x97,0x9C,0x68,0x68,0xF8,0x0D,0xF8,0x1F,0x8E,0x76,0x9E,0x63};

uint32_t Mutation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_or_supercolumn.read(iprot);
          this->__isset.column_or_supercolumn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->deletion.read(iprot);
          this->__isset.deletion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Mutation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Mutation");

  if (this->__isset.column_or_supercolumn) {
    xfer += oprot->writeFieldBegin("column_or_supercolumn", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->column_or_supercolumn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deletion) {
    xfer += oprot->writeFieldBegin("deletion", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->deletion.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Mutation &a, Mutation &b) {
  using ::std::swap;
  swap(a.column_or_supercolumn, b.column_or_supercolumn);
  swap(a.deletion, b.deletion);
  swap(a.__isset, b.__isset);
}

const char* EndpointDetails::ascii_fingerprint = "F4A50F0EC638C7F66026F9B6678FD89B";
const uint8_t EndpointDetails::binary_fingerprint[16] = {0xF4,0xA5,0x0F,0x0E,0xC6,0x38,0xC7,0xF6,0x60,0x26,0xF9,0xB6,0x67,0x8F,0xD8,0x9B};

uint32_t EndpointDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->datacenter);
          this->__isset.datacenter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rack);
          this->__isset.rack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EndpointDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EndpointDetails");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("datacenter", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->datacenter);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rack) {
    xfer += oprot->writeFieldBegin("rack", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->rack);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EndpointDetails &a, EndpointDetails &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.datacenter, b.datacenter);
  swap(a.rack, b.rack);
  swap(a.__isset, b.__isset);
}

const char* TokenRange::ascii_fingerprint = "832268DC4CD6B17EE8881FC57EA04679";
const uint8_t TokenRange::binary_fingerprint[16] = {0x83,0x22,0x68,0xDC,0x4C,0xD6,0xB1,0x7E,0xE8,0x88,0x1F,0xC5,0x7E,0xA0,0x46,0x79};

uint32_t TokenRange::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_start_token = false;
  bool isset_end_token = false;
  bool isset_endpoints = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_token);
          isset_start_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_token);
          isset_end_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->endpoints.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->endpoints.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += iprot->readString(this->endpoints[_i41]);
            }
            xfer += iprot->readListEnd();
          }
          isset_endpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rpc_endpoints.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->rpc_endpoints.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readString(this->rpc_endpoints[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rpc_endpoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->endpoint_details.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->endpoint_details.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += this->endpoint_details[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.endpoint_details = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_start_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_endpoints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TokenRange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TokenRange");

  xfer += oprot->writeFieldBegin("start_token", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start_token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->end_token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endpoints", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->endpoints.size()));
    std::vector<std::string> ::const_iterator _iter52;
    for (_iter52 = this->endpoints.begin(); _iter52 != this->endpoints.end(); ++_iter52)
    {
      xfer += oprot->writeString((*_iter52));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rpc_endpoints) {
    xfer += oprot->writeFieldBegin("rpc_endpoints", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->rpc_endpoints.size()));
      std::vector<std::string> ::const_iterator _iter53;
      for (_iter53 = this->rpc_endpoints.begin(); _iter53 != this->rpc_endpoints.end(); ++_iter53)
      {
        xfer += oprot->writeString((*_iter53));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.endpoint_details) {
    xfer += oprot->writeFieldBegin("endpoint_details", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->endpoint_details.size()));
      std::vector<EndpointDetails> ::const_iterator _iter54;
      for (_iter54 = this->endpoint_details.begin(); _iter54 != this->endpoint_details.end(); ++_iter54)
      {
        xfer += (*_iter54).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TokenRange &a, TokenRange &b) {
  using ::std::swap;
  swap(a.start_token, b.start_token);
  swap(a.end_token, b.end_token);
  swap(a.endpoints, b.endpoints);
  swap(a.rpc_endpoints, b.rpc_endpoints);
  swap(a.endpoint_details, b.endpoint_details);
  swap(a.__isset, b.__isset);
}

const char* AuthenticationRequest::ascii_fingerprint = "5EA2D527ECA3BA20C77AFC023EE8C05F";
const uint8_t AuthenticationRequest::binary_fingerprint[16] = {0x5E,0xA2,0xD5,0x27,0xEC,0xA3,0xBA,0x20,0xC7,0x7A,0xFC,0x02,0x3E,0xE8,0xC0,0x5F};

uint32_t AuthenticationRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_credentials = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->credentials.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _ktype56;
            ::apache::thrift::protocol::TType _vtype57;
            xfer += iprot->readMapBegin(_ktype56, _vtype57, _size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              std::string _key60;
              xfer += iprot->readString(_key60);
              std::string& _val61 = this->credentials[_key60];
              xfer += iprot->readString(_val61);
            }
            xfer += iprot->readMapEnd();
          }
          isset_credentials = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_credentials)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AuthenticationRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuthenticationRequest");

  xfer += oprot->writeFieldBegin("credentials", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->credentials.size()));
    std::map<std::string, std::string> ::const_iterator _iter62;
    for (_iter62 = this->credentials.begin(); _iter62 != this->credentials.end(); ++_iter62)
    {
      xfer += oprot->writeString(_iter62->first);
      xfer += oprot->writeString(_iter62->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuthenticationRequest &a, AuthenticationRequest &b) {
  using ::std::swap;
  swap(a.credentials, b.credentials);
}

const char* ColumnDef::ascii_fingerprint = "0D89CE83D7EDAD079AC3213ED1DCAA58";
const uint8_t ColumnDef::binary_fingerprint[16] = {0x0D,0x89,0xCE,0x83,0xD7,0xED,0xAD,0x07,0x9A,0xC3,0x21,0x3E,0xD1,0xDC,0xAA,0x58};

uint32_t ColumnDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_validation_class = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validation_class);
          isset_validation_class = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->index_type = (IndexType::type)ecast63;
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->index_options.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _ktype65;
            ::apache::thrift::protocol::TType _vtype66;
            xfer += iprot->readMapBegin(_ktype65, _vtype66, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _key69;
              xfer += iprot->readString(_key69);
              std::string& _val70 = this->index_options[_key69];
              xfer += iprot->readString(_val70);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.index_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_validation_class)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ColumnDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnDef");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("validation_class", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->validation_class);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.index_type) {
    xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->index_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_name) {
    xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->index_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.index_options) {
    xfer += oprot->writeFieldBegin("index_options", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->index_options.size()));
      std::map<std::string, std::string> ::const_iterator _iter71;
      for (_iter71 = this->index_options.begin(); _iter71 != this->index_options.end(); ++_iter71)
      {
        xfer += oprot->writeString(_iter71->first);
        xfer += oprot->writeString(_iter71->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnDef &a, ColumnDef &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.validation_class, b.validation_class);
  swap(a.index_type, b.index_type);
  swap(a.index_name, b.index_name);
  swap(a.index_options, b.index_options);
  swap(a.__isset, b.__isset);
}

const char* CfDef::ascii_fingerprint = "231A260521B5DD99EFBCCBDD8768CA7D";
const uint8_t CfDef::binary_fingerprint[16] = {0x23,0x1A,0x26,0x05,0x21,0xB5,0xDD,0x99,0xEF,0xBC,0xCB,0xDD,0x87,0x68,0xCA,0x7D};

uint32_t CfDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_keyspace = false;
  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->keyspace);
          isset_keyspace = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_type);
          this->__isset.column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comparator_type);
          this->__isset.comparator_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subcomparator_type);
          this->__isset.subcomparator_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->read_repair_chance);
          this->__isset.read_repair_chance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_metadata.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->column_metadata.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += this->column_metadata[_i76].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gc_grace_seconds);
          this->__isset.gc_grace_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_validation_class);
          this->__isset.default_validation_class = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->min_compaction_threshold);
          this->__isset.min_compaction_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_compaction_threshold);
          this->__isset.max_compaction_threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replicate_on_write);
          this->__isset.replicate_on_write = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key_validation_class);
          this->__isset.key_validation_class = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key_alias);
          this->__isset.key_alias = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->compaction_strategy);
          this->__isset.compaction_strategy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->compaction_strategy_options.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _ktype78;
            ::apache::thrift::protocol::TType _vtype79;
            xfer += iprot->readMapBegin(_ktype78, _vtype79, _size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              std::string _key82;
              xfer += iprot->readString(_key82);
              std::string& _val83 = this->compaction_strategy_options[_key82];
              xfer += iprot->readString(_val83);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.compaction_strategy_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->compression_options.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _ktype85;
            ::apache::thrift::protocol::TType _vtype86;
            xfer += iprot->readMapBegin(_ktype85, _vtype86, _size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              std::string _key89;
              xfer += iprot->readString(_key89);
              std::string& _val90 = this->compression_options[_key89];
              xfer += iprot->readString(_val90);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.compression_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 33:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->bloom_filter_fp_chance);
          this->__isset.bloom_filter_fp_chance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->caching);
          this->__isset.caching = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 37:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dclocal_read_repair_chance);
          this->__isset.dclocal_read_repair_chance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->row_cache_size);
          this->__isset.row_cache_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->key_cache_size);
          this->__isset.key_cache_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->row_cache_save_period_in_seconds);
          this->__isset.row_cache_save_period_in_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key_cache_save_period_in_seconds);
          this->__isset.key_cache_save_period_in_seconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memtable_flush_after_mins);
          this->__isset.memtable_flush_after_mins = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memtable_throughput_in_mb);
          this->__isset.memtable_throughput_in_mb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->memtable_operations_in_millions);
          this->__isset.memtable_operations_in_millions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->merge_shards_chance);
          this->__isset.merge_shards_chance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->row_cache_provider);
          this->__isset.row_cache_provider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 31:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->row_cache_keys_to_save);
          this->__isset.row_cache_keys_to_save = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_keyspace)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CfDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CfDef");

  xfer += oprot->writeFieldBegin("keyspace", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->keyspace);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.column_type) {
    xfer += oprot->writeFieldBegin("column_type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->column_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comparator_type) {
    xfer += oprot->writeFieldBegin("comparator_type", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->comparator_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.subcomparator_type) {
    xfer += oprot->writeFieldBegin("subcomparator_type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->subcomparator_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_cache_size) {
    xfer += oprot->writeFieldBegin("row_cache_size", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->row_cache_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_cache_size) {
    xfer += oprot->writeFieldBegin("key_cache_size", ::apache::thrift::protocol::T_DOUBLE, 11);
    xfer += oprot->writeDouble(this->key_cache_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.read_repair_chance) {
    xfer += oprot->writeFieldBegin("read_repair_chance", ::apache::thrift::protocol::T_DOUBLE, 12);
    xfer += oprot->writeDouble(this->read_repair_chance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_metadata) {
    xfer += oprot->writeFieldBegin("column_metadata", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_metadata.size()));
      std::vector<ColumnDef> ::const_iterator _iter91;
      for (_iter91 = this->column_metadata.begin(); _iter91 != this->column_metadata.end(); ++_iter91)
      {
        xfer += (*_iter91).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gc_grace_seconds) {
    xfer += oprot->writeFieldBegin("gc_grace_seconds", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->gc_grace_seconds);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_validation_class) {
    xfer += oprot->writeFieldBegin("default_validation_class", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->default_validation_class);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_compaction_threshold) {
    xfer += oprot->writeFieldBegin("min_compaction_threshold", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32(this->min_compaction_threshold);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_compaction_threshold) {
    xfer += oprot->writeFieldBegin("max_compaction_threshold", ::apache::thrift::protocol::T_I32, 18);
    xfer += oprot->writeI32(this->max_compaction_threshold);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_cache_save_period_in_seconds) {
    xfer += oprot->writeFieldBegin("row_cache_save_period_in_seconds", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->row_cache_save_period_in_seconds);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_cache_save_period_in_seconds) {
    xfer += oprot->writeFieldBegin("key_cache_save_period_in_seconds", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32(this->key_cache_save_period_in_seconds);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memtable_flush_after_mins) {
    xfer += oprot->writeFieldBegin("memtable_flush_after_mins", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32(this->memtable_flush_after_mins);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memtable_throughput_in_mb) {
    xfer += oprot->writeFieldBegin("memtable_throughput_in_mb", ::apache::thrift::protocol::T_I32, 22);
    xfer += oprot->writeI32(this->memtable_throughput_in_mb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memtable_operations_in_millions) {
    xfer += oprot->writeFieldBegin("memtable_operations_in_millions", ::apache::thrift::protocol::T_DOUBLE, 23);
    xfer += oprot->writeDouble(this->memtable_operations_in_millions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replicate_on_write) {
    xfer += oprot->writeFieldBegin("replicate_on_write", ::apache::thrift::protocol::T_BOOL, 24);
    xfer += oprot->writeBool(this->replicate_on_write);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.merge_shards_chance) {
    xfer += oprot->writeFieldBegin("merge_shards_chance", ::apache::thrift::protocol::T_DOUBLE, 25);
    xfer += oprot->writeDouble(this->merge_shards_chance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_validation_class) {
    xfer += oprot->writeFieldBegin("key_validation_class", ::apache::thrift::protocol::T_STRING, 26);
    xfer += oprot->writeString(this->key_validation_class);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_cache_provider) {
    xfer += oprot->writeFieldBegin("row_cache_provider", ::apache::thrift::protocol::T_STRING, 27);
    xfer += oprot->writeString(this->row_cache_provider);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_alias) {
    xfer += oprot->writeFieldBegin("key_alias", ::apache::thrift::protocol::T_STRING, 28);
    xfer += oprot->writeBinary(this->key_alias);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compaction_strategy) {
    xfer += oprot->writeFieldBegin("compaction_strategy", ::apache::thrift::protocol::T_STRING, 29);
    xfer += oprot->writeString(this->compaction_strategy);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compaction_strategy_options) {
    xfer += oprot->writeFieldBegin("compaction_strategy_options", ::apache::thrift::protocol::T_MAP, 30);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->compaction_strategy_options.size()));
      std::map<std::string, std::string> ::const_iterator _iter92;
      for (_iter92 = this->compaction_strategy_options.begin(); _iter92 != this->compaction_strategy_options.end(); ++_iter92)
      {
        xfer += oprot->writeString(_iter92->first);
        xfer += oprot->writeString(_iter92->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.row_cache_keys_to_save) {
    xfer += oprot->writeFieldBegin("row_cache_keys_to_save", ::apache::thrift::protocol::T_I32, 31);
    xfer += oprot->writeI32(this->row_cache_keys_to_save);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compression_options) {
    xfer += oprot->writeFieldBegin("compression_options", ::apache::thrift::protocol::T_MAP, 32);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->compression_options.size()));
      std::map<std::string, std::string> ::const_iterator _iter93;
      for (_iter93 = this->compression_options.begin(); _iter93 != this->compression_options.end(); ++_iter93)
      {
        xfer += oprot->writeString(_iter93->first);
        xfer += oprot->writeString(_iter93->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bloom_filter_fp_chance) {
    xfer += oprot->writeFieldBegin("bloom_filter_fp_chance", ::apache::thrift::protocol::T_DOUBLE, 33);
    xfer += oprot->writeDouble(this->bloom_filter_fp_chance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.caching) {
    xfer += oprot->writeFieldBegin("caching", ::apache::thrift::protocol::T_STRING, 34);
    xfer += oprot->writeString(this->caching);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dclocal_read_repair_chance) {
    xfer += oprot->writeFieldBegin("dclocal_read_repair_chance", ::apache::thrift::protocol::T_DOUBLE, 37);
    xfer += oprot->writeDouble(this->dclocal_read_repair_chance);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CfDef &a, CfDef &b) {
  using ::std::swap;
  swap(a.keyspace, b.keyspace);
  swap(a.name, b.name);
  swap(a.column_type, b.column_type);
  swap(a.comparator_type, b.comparator_type);
  swap(a.subcomparator_type, b.subcomparator_type);
  swap(a.comment, b.comment);
  swap(a.read_repair_chance, b.read_repair_chance);
  swap(a.column_metadata, b.column_metadata);
  swap(a.gc_grace_seconds, b.gc_grace_seconds);
  swap(a.default_validation_class, b.default_validation_class);
  swap(a.id, b.id);
  swap(a.min_compaction_threshold, b.min_compaction_threshold);
  swap(a.max_compaction_threshold, b.max_compaction_threshold);
  swap(a.replicate_on_write, b.replicate_on_write);
  swap(a.key_validation_class, b.key_validation_class);
  swap(a.key_alias, b.key_alias);
  swap(a.compaction_strategy, b.compaction_strategy);
  swap(a.compaction_strategy_options, b.compaction_strategy_options);
  swap(a.compression_options, b.compression_options);
  swap(a.bloom_filter_fp_chance, b.bloom_filter_fp_chance);
  swap(a.caching, b.caching);
  swap(a.dclocal_read_repair_chance, b.dclocal_read_repair_chance);
  swap(a.row_cache_size, b.row_cache_size);
  swap(a.key_cache_size, b.key_cache_size);
  swap(a.row_cache_save_period_in_seconds, b.row_cache_save_period_in_seconds);
  swap(a.key_cache_save_period_in_seconds, b.key_cache_save_period_in_seconds);
  swap(a.memtable_flush_after_mins, b.memtable_flush_after_mins);
  swap(a.memtable_throughput_in_mb, b.memtable_throughput_in_mb);
  swap(a.memtable_operations_in_millions, b.memtable_operations_in_millions);
  swap(a.merge_shards_chance, b.merge_shards_chance);
  swap(a.row_cache_provider, b.row_cache_provider);
  swap(a.row_cache_keys_to_save, b.row_cache_keys_to_save);
  swap(a.__isset, b.__isset);
}

const char* KsDef::ascii_fingerprint = "0767851B6476EB3777A21E59E912E11A";
const uint8_t KsDef::binary_fingerprint[16] = {0x07,0x67,0x85,0x1B,0x64,0x76,0xEB,0x37,0x77,0xA2,0x1E,0x59,0xE9,0x12,0xE1,0x1A};

uint32_t KsDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_strategy_class = false;
  bool isset_cf_defs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strategy_class);
          isset_strategy_class = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->strategy_options.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _ktype95;
            ::apache::thrift::protocol::TType _vtype96;
            xfer += iprot->readMapBegin(_ktype95, _vtype96, _size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              std::string _key99;
              xfer += iprot->readString(_key99);
              std::string& _val100 = this->strategy_options[_key99];
              xfer += iprot->readString(_val100);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.strategy_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replication_factor);
          this->__isset.replication_factor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cf_defs.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readListBegin(_etype104, _size101);
            this->cf_defs.resize(_size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              xfer += this->cf_defs[_i105].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_cf_defs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->durable_writes);
          this->__isset.durable_writes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_strategy_class)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cf_defs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KsDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("KsDef");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strategy_class", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->strategy_class);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.strategy_options) {
    xfer += oprot->writeFieldBegin("strategy_options", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->strategy_options.size()));
      std::map<std::string, std::string> ::const_iterator _iter106;
      for (_iter106 = this->strategy_options.begin(); _iter106 != this->strategy_options.end(); ++_iter106)
      {
        xfer += oprot->writeString(_iter106->first);
        xfer += oprot->writeString(_iter106->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replication_factor) {
    xfer += oprot->writeFieldBegin("replication_factor", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->replication_factor);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("cf_defs", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cf_defs.size()));
    std::vector<CfDef> ::const_iterator _iter107;
    for (_iter107 = this->cf_defs.begin(); _iter107 != this->cf_defs.end(); ++_iter107)
    {
      xfer += (*_iter107).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.durable_writes) {
    xfer += oprot->writeFieldBegin("durable_writes", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->durable_writes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KsDef &a, KsDef &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.strategy_class, b.strategy_class);
  swap(a.strategy_options, b.strategy_options);
  swap(a.replication_factor, b.replication_factor);
  swap(a.cf_defs, b.cf_defs);
  swap(a.durable_writes, b.durable_writes);
  swap(a.__isset, b.__isset);
}

const char* CqlRow::ascii_fingerprint = "470EFC558004E98D92D604898305C04E";
const uint8_t CqlRow::binary_fingerprint[16] = {0x47,0x0E,0xFC,0x55,0x80,0x04,0xE9,0x8D,0x92,0xD6,0x04,0x89,0x83,0x05,0xC0,0x4E};

uint32_t CqlRow::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;
  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size108;
            ::apache::thrift::protocol::TType _etype111;
            xfer += iprot->readListBegin(_etype111, _size108);
            this->columns.resize(_size108);
            uint32_t _i112;
            for (_i112 = 0; _i112 < _size108; ++_i112)
            {
              xfer += this->columns[_i112].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CqlRow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CqlRow");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<Column> ::const_iterator _iter113;
    for (_iter113 = this->columns.begin(); _iter113 != this->columns.end(); ++_iter113)
    {
      xfer += (*_iter113).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CqlRow &a, CqlRow &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.columns, b.columns);
}

const char* CqlMetadata::ascii_fingerprint = "B7C5A4AA9652C744A48EBC1C12D531E7";
const uint8_t CqlMetadata::binary_fingerprint[16] = {0xB7,0xC5,0xA4,0xAA,0x96,0x52,0xC7,0x44,0xA4,0x8E,0xBC,0x1C,0x12,0xD5,0x31,0xE7};

uint32_t CqlMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name_types = false;
  bool isset_value_types = false;
  bool isset_default_name_type = false;
  bool isset_default_value_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->name_types.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _ktype115;
            ::apache::thrift::protocol::TType _vtype116;
            xfer += iprot->readMapBegin(_ktype115, _vtype116, _size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              std::string _key119;
              xfer += iprot->readBinary(_key119);
              std::string& _val120 = this->name_types[_key119];
              xfer += iprot->readString(_val120);
            }
            xfer += iprot->readMapEnd();
          }
          isset_name_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->value_types.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _ktype122;
            ::apache::thrift::protocol::TType _vtype123;
            xfer += iprot->readMapBegin(_ktype122, _vtype123, _size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              std::string _key126;
              xfer += iprot->readBinary(_key126);
              std::string& _val127 = this->value_types[_key126];
              xfer += iprot->readString(_val127);
            }
            xfer += iprot->readMapEnd();
          }
          isset_value_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_name_type);
          isset_default_name_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_value_type);
          isset_default_value_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_default_name_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_default_value_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CqlMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CqlMetadata");

  xfer += oprot->writeFieldBegin("name_types", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->name_types.size()));
    std::map<std::string, std::string> ::const_iterator _iter128;
    for (_iter128 = this->name_types.begin(); _iter128 != this->name_types.end(); ++_iter128)
    {
      xfer += oprot->writeBinary(_iter128->first);
      xfer += oprot->writeString(_iter128->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value_types", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->value_types.size()));
    std::map<std::string, std::string> ::const_iterator _iter129;
    for (_iter129 = this->value_types.begin(); _iter129 != this->value_types.end(); ++_iter129)
    {
      xfer += oprot->writeBinary(_iter129->first);
      xfer += oprot->writeString(_iter129->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("default_name_type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->default_name_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("default_value_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->default_value_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CqlMetadata &a, CqlMetadata &b) {
  using ::std::swap;
  swap(a.name_types, b.name_types);
  swap(a.value_types, b.value_types);
  swap(a.default_name_type, b.default_name_type);
  swap(a.default_value_type, b.default_value_type);
}

const char* CqlResult::ascii_fingerprint = "521B9CE5AF77539F7267F6952B609E81";
const uint8_t CqlResult::binary_fingerprint[16] = {0x52,0x1B,0x9C,0xE5,0xAF,0x77,0x53,0x9F,0x72,0x67,0xF6,0x95,0x2B,0x60,0x9E,0x81};

uint32_t CqlResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast130;
          xfer += iprot->readI32(ecast130);
          this->type = (CqlResultType::type)ecast130;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size131;
            ::apache::thrift::protocol::TType _etype134;
            xfer += iprot->readListBegin(_etype134, _size131);
            this->rows.resize(_size131);
            uint32_t _i135;
            for (_i135 = 0; _i135 < _size131; ++_i135)
            {
              xfer += this->rows[_i135].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->schema.read(iprot);
          this->__isset.schema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CqlResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CqlResult");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rows) {
    xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->rows.size()));
      std::vector<CqlRow> ::const_iterator _iter136;
      for (_iter136 = this->rows.begin(); _iter136 != this->rows.end(); ++_iter136)
      {
        xfer += (*_iter136).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num) {
    xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->num);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schema) {
    xfer += oprot->writeFieldBegin("schema", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->schema.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CqlResult &a, CqlResult &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.rows, b.rows);
  swap(a.num, b.num);
  swap(a.schema, b.schema);
  swap(a.__isset, b.__isset);
}

const char* CqlPreparedResult::ascii_fingerprint = "7E1663EC688DFDC28722BF36F9F64E6F";
const uint8_t CqlPreparedResult::binary_fingerprint[16] = {0x7E,0x16,0x63,0xEC,0x68,0x8D,0xFD,0xC2,0x87,0x22,0xBF,0x36,0xF9,0xF6,0x4E,0x6F};

uint32_t CqlPreparedResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_itemId = false;
  bool isset_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemId);
          isset_itemId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          isset_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->variable_types.clear();
            uint32_t _size137;
            ::apache::thrift::protocol::TType _etype140;
            xfer += iprot->readListBegin(_etype140, _size137);
            this->variable_types.resize(_size137);
            uint32_t _i141;
            for (_i141 = 0; _i141 < _size137; ++_i141)
            {
              xfer += iprot->readString(this->variable_types[_i141]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.variable_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->variable_names.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readListBegin(_etype145, _size142);
            this->variable_names.resize(_size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              xfer += iprot->readString(this->variable_names[_i146]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.variable_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_itemId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CqlPreparedResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CqlPreparedResult");

  xfer += oprot->writeFieldBegin("itemId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->itemId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.variable_types) {
    xfer += oprot->writeFieldBegin("variable_types", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->variable_types.size()));
      std::vector<std::string> ::const_iterator _iter147;
      for (_iter147 = this->variable_types.begin(); _iter147 != this->variable_types.end(); ++_iter147)
      {
        xfer += oprot->writeString((*_iter147));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.variable_names) {
    xfer += oprot->writeFieldBegin("variable_names", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->variable_names.size()));
      std::vector<std::string> ::const_iterator _iter148;
      for (_iter148 = this->variable_names.begin(); _iter148 != this->variable_names.end(); ++_iter148)
      {
        xfer += oprot->writeString((*_iter148));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CqlPreparedResult &a, CqlPreparedResult &b) {
  using ::std::swap;
  swap(a.itemId, b.itemId);
  swap(a.count, b.count);
  swap(a.variable_types, b.variable_types);
  swap(a.variable_names, b.variable_names);
  swap(a.__isset, b.__isset);
}

const char* CfSplit::ascii_fingerprint = "A0ED90CE9B69D7A0FCE24E26CAECD2AF";
const uint8_t CfSplit::binary_fingerprint[16] = {0xA0,0xED,0x90,0xCE,0x9B,0x69,0xD7,0xA0,0xFC,0xE2,0x4E,0x26,0xCA,0xEC,0xD2,0xAF};

uint32_t CfSplit::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_start_token = false;
  bool isset_end_token = false;
  bool isset_row_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_token);
          isset_start_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_token);
          isset_end_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_count);
          isset_row_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_start_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_end_token)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CfSplit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CfSplit");

  xfer += oprot->writeFieldBegin("start_token", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start_token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->end_token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_count", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->row_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CfSplit &a, CfSplit &b) {
  using ::std::swap;
  swap(a.start_token, b.start_token);
  swap(a.end_token, b.end_token);
  swap(a.row_count, b.row_count);
}

}}} // namespace
