/**
 * @file Compressor.h
 * @brief The header file of Compressor.
 * @author Peisheng Wang
 * @date 2008-10-22
 * 
 * This file defines class Compressor.
 * 
 *  Change from jiazeng's work:
 *  ============================
 *  1. When compressing a file, it stores bitPattern instead of alphabet tree in compressing.
 *  2. We use greedy algorithm to find the index for makeing left sub tree and right sub tree.
 *     And its complexity is O(n). 
 *  3. After experiment, compressing is much faster, while decompressing is almost the same.
 *  4. Add interface to set bitPatttern:
 *         void setBitPattern(const string& compressedFile)
 *         void setBitPattern(const BitPattern& bp)
 *  5. Add showCode() method to display the corresponding compressed bit strings for very keyword of inputFile 	
 *         void showCode(const string& inputFile, const string& outputFile);
 *
 *  6. Make it more scable and extendible. 
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <iostream>
#include <map>
#include <vector>
#include <bitset>
#include <stack>
#include <queue>
#include <algorithm>
#include <numeric>

#include "CompressorException.h"
#include "BitPattern.h"
#include "PatternGenerator.h"

using namespace std;

/** 
 *  \brief Order preserving compressor header file.
 *
 *  This file defines an order preserving compressor.
 */

namespace izenelib {
namespace compression {


struct CompressedString {
	unsigned int bitlength;
	string bits;
};

/** \brief Order preserving compressor.
 *
 *  This compressor can be used to compress a text file to compressed form by order preserving compression algorithm.
 *   And it can also decompress a compressed file generated by itself.
 *
 */
class Compressor {
	/* compressor to perform linear compression */

public:
	/**
	 *   \brief default constructor
	 */
	Compressor();
	/**
	 *   \brief default deconstructor
	 */
	~Compressor();
	/**
	 *   \brief constructor from a plaintext file
	 *         
	 *   @param fileName the file is used to initialize bitPattern. 
	 * 
	 */
	Compressor(const string& fileName) :
		pg_(fileName) {
		bitPattern_ = pg_.getBitPattern();
	}

	/**
	 *   \brief constructor from a plaintext file
	 *         
	 *   @param fileName the file is used to initialize bitPattern. 
	 *   @param NOFILE it true, it dones't encode '\n'.
	 */
	Compressor(const string& fileName, bool NOFILE=false) :
		pg_(fileName, NOFILE) {
		bitPattern_ = pg_.getBitPattern();
	}

	Compressor(const BitPattern& bp) :
		bitPattern_(bp) {
	}
	/**
	 *   \brief set the BitPattern thourgh given file
	 * 
	 *   @param fileName must be a compressed file or file that contains Bitpatten in the head.
	 */
	void setBitPattern(const string& compressedFile) {
		FILE *fp;
		fp = fopen(compressedFile.c_str(), "r");
		bitPattern_.fromFile(fp);
	}
	/**
	 *  \brief set the bitpattern directly, 
	 * 
	 */
	void setBitPattern(const BitPattern& bp) {
		bitPattern_ = bp;
	}
	/**
	 *  \brief get the bitpattern. 
	 * 
	 */
	BitPattern& getBitPattern() {
		return bitPattern_;
	}

	/**
	 *  \brief compress  a given string input and save it in output. 
	 *
	 *  @param output also contains actual bits length.
	 */
	void compressString(const string& input, CompressedString& output);
	/**
	 *  \brief compress  a given string input and save it in output. 
	 *
	 */
	void decompressString(const CompressedString& input, string& output);

	/**
	 *  \brief compress  a given file and save it in the output file.
	 * 
	 *  @param UseDefaultPattern if false, use the bitPattern generated from input file, otherwise use bitPattern already exists. 
	 *
	 */
	void compressFile(const string& inputFile, const string& outputFile,
			bool UseDefaultPattern=0);

	/**
	 *  \brief decompress from a file
	 * 
	 *  @param SaveBitPattern if true save BitPattern in file header, otherwise not
	 *  note that, if not save bitpattern, then the corressponding bitPattern must be provied when decompressing. 
	 *
	 */
	void decompressFile(const string& compressfile, const string& textfile);
	/**
	 *   \brief show the bitpattern in text of each line of input file.
	 * 
	 */
	void showCode(const string& inputFile, const string& outputFile);
	/**
	 *  \brief display the info of bitPattern.
	 */
	void displayPattern() {
		bitPattern_.display();
	}

	/**
	 *   \brief show the bitpattern in text of input string.	    
	 */
	void showEncode(const string& input, string& output);

	/**
	 *   \brief show the original text of  compressed string in bit text.	    
	 */
	void showDecode(const string& input, string& output);

	/*unsigned int stringToInt1(const string& input) {

		char ch;
		int h = 0;
		int cnt = 0;
		ub4 mask = 0x80000000;

		size_t sz = input.size();
		for (unsigned int k = 0; k < sz; k++) {
			ch = input[k];
			Pattern bincode = bitPattern_.getPattern(ch);
			for (size_t i=0; i<bincode.nbits; i++) {
				cnt++;
				if (bincode.bits & (mask>>i)) {
					h = h*2 + 1;
					//output.push_back('1');
				} else {
					h = h*2;
				}
				//output.push_back('0');
				if( cnt >= 32 )
					return h;
				
			}
		}
		if( cnt <32 )
			h <<= (32-cnt);
		return h;
	}*/
	
	unsigned int stringToInt(const string& input) {

		char ch;
		int h = 0;
		int cnt = 0;
		int acc = 1;
		ub4 mask = 0x80000000;

		size_t sz = input.size();
		for (unsigned int k = 0; k < sz; k++) {
			ch = input[k];
			Pattern bincode = bitPattern_.getPattern(ch);
			for (size_t i=0; i<bincode.nbits; i++) {
				cnt++;
				if (bincode.bits & (mask>>i)) {
					h |= acc;
					//output.push_back('1');
				} else {
					//h = h*2;
				}
				acc <<= 1;
				//output.push_back('0');
				if(cnt >= 32)
					return h;
				
			}
		}	
		return h;
	}
	

private:
	//Tree  *tree_; // internal storage for tree
	BitPattern bitPattern_; // internal storage for compression scheme	
	//TreeAlgorithm ta_; 
	PatternGenerator pg_;//used to generate pattern.
};

}
} // namespace
